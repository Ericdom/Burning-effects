<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Burning Text Effect</title>
    <style>
        :root {
            --primary-glow: #ff4d00;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
        }

        #card-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
        }

        #card {
            width: 320px;
            padding: 30px;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            border-radius: 12px;
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
            transition: opacity 0.5s ease;
            position: relative;
            overflow: hidden;
        }

        /* The white text will be "eaten" by the shader mask, so we don't need complex CSS masks here,
           but we'll hide the actual div when the burn is done */
        #card.burning {
            pointer-events: none;
        }

        h2 {
            margin-top: 0;
            font-size: 1.5rem;
            color: #ffca28;
        }

        p {
            line-height: 1.6;
            opacity: 0.9;
        }

        #controls {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            display: flex;
            gap: 15px;
        }

        button {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            border-radius: 50px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.8rem;
        }

        button:hover {
            background: rgba(255, 77, 0, 0.2);
            border-color: #ff4d00;
            box-shadow: 0 0 20px rgba(255, 77, 0, 0.3);
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        #reset-btn {
            display: none;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* Navbar Styles */
        nav {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            gap: 10px;
        }

        .nav-link {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.05);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.8);
            text-decoration: none;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .nav-link:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-color: rgba(255, 255, 255, 0.2);
        }

        .nav-link.active {
            background: rgba(255, 77, 0, 0.1);
            border-color: #ff4d00;
            color: #ffca28;
        }
    </style>
</head>

<body>
    <nav>
        <a href="index.html" class="nav-link active">Home</a>
        <a href="gallery.html" class="nav-link">Gallery</a>
    </nav>
    <div id="card-container">
        <div id="card">
            <h2>Release Your Thoughts</h2>
            <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Write down what's weighing on you, then let the
                fire consume it. Every ending is just a new beginning.</p>
        </div>
    </div>

    <div id="controls">
        <button id="burn-btn">Burn it</button>
        <button id="reset-btn">Reset</button>
    </div>

    <canvas id="canvas"></canvas>

    <script id="vs" type="x-shader/x-vertex">
        attribute vec2 position;
        void main() {
            gl_Position = vec4(position, 0.0, 1.0);
        }
    </script>

    <script id="fs" type="x-shader/x-fragment">
        precision highp float;
        uniform float uTime;
        uniform float uProgress;
        uniform vec2 uResolution;
        uniform vec2 uCardSize;
        uniform vec2 uCardPos;

        // Better noise implementation (simpler Value Noise for performance and look)
        float hash(vec2 p) {
            p = fract(p * vec2(123.34, 456.21));
            p += dot(p, p + 45.32);
            return fract(p.x * p.y);
        }

        float noise(vec2 p) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            f = f * f * (3.0 - 2.0 * f);
            float a = hash(i);
            float b = hash(i + vec2(1.0, 0.0));
            float c = hash(i + vec2(0.0, 1.0));
            float d = hash(i + vec2(1.0, 1.0));
            return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
        }

        float fbm(vec2 p) {
            float v = 0.0;
            float a = 0.5;
            vec2 shift = vec2(100.0);
            for (int i = 0; i < 5; ++i) {
                v += a * noise(p);
                p = p * 2.0 + shift;
                a *= 0.5;
            }
            return v;
        }

        void main() {
            vec2 uv = gl_FragCoord.xy / uResolution.xy;
            float pixelX = uv.x * uResolution.x;
            float pixelY = (1.0 - uv.y) * uResolution.y;

            // Normalize UV for noise (aspect correct)
            vec2 noiseUv = uv * vec2(uResolution.x / uResolution.y, 1.0);
            
            // Generate fire noise
            float n = fbm(noiseUv * 3.0 - vec2(0.0, uTime * 0.8));
            float n2 = fbm(noiseUv * 6.0 - vec2(0.0, uTime * 1.5));
            
            // Burning progress logic
            // progress 0.0 to 1.0
            // We want the burn to start from bottom to top or middle out.
            // Let's go bottom to top + some organic variability.
            
            float burnMask = 1.0 - (uv.y + (n - 0.5) * 0.4);
            // Re-map burnMask so it sweeps from 1 to -1 as progress goes 0 to 1
            float currentLimit = 1.0 - uProgress * 2.0; 
            float intensity = smoothstep(currentLimit, currentLimit + 0.3, burnMask);
            
            // Card boundaries
            float cardLeft = uCardPos.x - uCardSize.x / 2.0;
            float cardRight = uCardPos.x + uCardSize.x / 2.0;
            float cardTop = uCardPos.y - uCardSize.y / 2.0;
            float cardBottom = uCardPos.y + uCardSize.y / 2.0;

            bool insideCard = (pixelX >= cardLeft && pixelX <= cardRight && 
                               pixelY >= cardTop && pixelY <= cardBottom);

            // Fire Colors
            vec3 fireColor = mix(vec3(1.0, 0.1, 0.0), vec3(1.0, 0.8, 0.0), intensity);
            fireColor = mix(fireColor, vec3(1.0, 1.0, 0.5), smoothstep(0.7, 1.0, intensity));

            // Edge of the burn (embers)
            float edge = smoothstep(currentLimit, currentLimit + 0.1, burnMask) - intensity;
            vec3 emberColor = vec3(1.5, 0.4, 0.1) * edge;

            float alpha = intensity;
            
            // If uProgress is 0, we just show some background atmosphere or nothing
            // If uProgress > 0, we show the fire and dissolve
            
            vec3 finalColor = fireColor * intensity * 1.5 + emberColor * 2.0;
            
            // Atmospheric flames at the bottom regardless of card
            float bottomFire = smoothstep(0.3, 0.0, uv.y + (n2 - 0.5) * 0.2);
            finalColor += vec3(1.0, 0.3, 0.0) * bottomFire * 0.5;

            // Dissolve card text/background based on the same mask
            // This shader only renders the FIRE. The card itself is a div.
            // To make it look like the card is being eaten, we either:
            // 1. Render the card IN the shader (complex for fonts)
            // 2. Use the shader to render a "mask" that we apply to the card.
            // Let's stick to the fire effect being aligned with the card dissolution.
            
            gl_FragColor = vec4(finalColor, clamp(alpha + bottomFire * 0.5, 0.0, 1.0));
        }
    </script>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');
        const card = document.getElementById('card');
        const burnBtn = document.getElementById('burn-btn');
        const resetBtn = document.getElementById('reset-btn');

        let progress = 0;
        let isBurning = false;
        let startTime = Date.now();

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        // Compile Shaders
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vsSource = document.getElementById('vs').text;
        const fsSource = document.getElementById('fs').text;
        const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

        const program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        gl.useProgram(program);

        const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, 1]);
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const position = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(position);
        gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);

        const uTime = gl.getUniformLocation(program, 'uTime');
        const uProgress = gl.getUniformLocation(program, 'uProgress');
        const uResolution = gl.getUniformLocation(program, 'uResolution');
        const uCardSize = gl.getUniformLocation(program, 'uCardSize');
        const uCardPos = gl.getUniformLocation(program, 'uCardPos');

        function updateCardUniforms() {
            const rect = card.getBoundingClientRect();
            gl.uniform2f(uCardSize, rect.width, rect.height);
            // Center of card
            gl.uniform2f(uCardPos, rect.left + rect.width / 2, rect.top + rect.height / 2);
        }

        burnBtn.addEventListener('click', () => {
            isBurning = true;
            startTime = Date.now();
            // Store state in localStorage
            localStorage.setItem('burn_state', JSON.stringify({
                isBurning: true,
                startTime: startTime
            }));
            burnBtn.style.display = 'none';
            card.classList.add('burning');
        });

        function resetEffect() {
            progress = 0;
            isBurning = false;
            // Clear localStorage
            localStorage.removeItem('burn_state');
            card.style.opacity = '1';
            card.style.filter = 'none';
            card.classList.remove('burning');
            burnBtn.style.display = 'block';
            resetBtn.style.display = 'none';
        }

        resetBtn.addEventListener('click', resetEffect);

        // Load state on start
        const savedState = localStorage.getItem('burn_state');
        if (savedState) {
            const state = JSON.parse(savedState);
            isBurning = state.isBurning;
            startTime = state.startTime;

            if (isBurning) {
                burnBtn.style.display = 'none';
                card.classList.add('burning');
                // Calculate initial progress based on elapsed time
                const elapsedSeconds = (Date.now() - startTime) / 1000;
                // progress increment is 0.005 per frame (~60fps)
                // 0.005 * 60 = 0.3 progress per second
                progress = elapsedSeconds * 0.3;
            }
        }

        function animate() {
            const now = (Date.now() - startTime) / 1000;

            if (isBurning) {
                // Accelerate as it goes to finish faster
                progress += 0.005 + (progress * 0.01);
                if (progress > 1.05) {
                    // Auto-reset once done
                    resetEffect();
                }

                // Sync CSS fade/blur with progress
                // We'll fade the card as it "burns"
                // The shader mask is bottom-up (uv.y from 0 to 1)
                // We'll use a CSS mask or just simple opacity for now to keep it clean
                if (isBurning && progress > 0.1) {
                    const fade = Math.max(0, 1 - (progress - 0.1) * 1.5);
                    card.style.opacity = fade.toString();
                    card.style.filter = `blur(${(progress * 20)}px) brightness(${1 + progress})`;
                }
            }

            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.uniform1f(uTime, now);
            gl.uniform1f(uProgress, Math.min(progress, 1.0));
            gl.uniform2f(uResolution, canvas.width, canvas.height);
            updateCardUniforms();

            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>

</html>